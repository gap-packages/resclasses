<!-- #################################################################### -->
<!-- ##                                                                ## -->
<!-- ##  fixedrep.xml      ResClasses documentation       Stefan Kohl  ## -->
<!-- ##                                                                ## -->
<!-- ##  $Id$     ## -->
<!-- ##                                                                ## -->
<!-- #################################################################### -->

<Chapter Label="ch:UnionsOfResidueClassesWithFixedReps">
<Heading>Unions of Residue Classes with Fixed Representatives</Heading>

&ResClasses; supports computations with unions of residue classes which
are endowed with distinguished (<Q>fixed</Q>) representatives.
These unions of residue classes can be viewed as multisets of ring elements.
The residue classes forming such a union do not need to be disjoint or even
only distinct.

<!-- #################################################################### -->

<Section Label="sec:DefiningUnionsOfResidueClassesWithFixedReps">
<Heading>
  Entering unions of residue classes with fixed representatives
</Heading>

<ManSection>
  <Func Name="ResidueClassWithFixedRep"
        Arg="R, m, r" Label="R, m, r"/>
  <Func Name="ResidueClassWithFixedRep"
        Arg="m, r" Label="m, r"/>
  <Returns>
    The residue class <A>r</A>&nbsp;mod&nbsp;<A>m</A> of the
    ring&nbsp;<A>R</A>, with the fixed representative&nbsp;<A>r</A>.
  </Returns>
  <Description>
    If the argument <A>R</A> is omitted, it defaults to <C>Integers</C>.
<Example>
<![CDATA[
gap> ResidueClassWithFixedRep(Integers,2,1);
[1/2]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Func Name="ResidueClassUnionWithFixedReps"
        Arg="R, classes" Label="R, classes"/>
  <Func Name="ResidueClassUnionWithFixedReps"
        Arg="classes" Label="classes"/>
  <Returns>
    The union of the residue classes <A>classes</A>[<M>i</M>][2] mod
    <A>classes</A>[<M>i</M>][1] of the ring <A>R</A>, with fixed
    representatives <A>classes</A>[<M>i</M>][2].
  </Returns>
  <Description>
    The argument <A>classes</A> must be a list of pairs of elements of the
    ring <A>R</A>. Their first entries -- the moduli -- must be nonzero.
    If the argument <A>R</A> is omitted, it defaults to <C>Integers</C>.
<Example>
<![CDATA[
gap> ResidueClassUnionWithFixedReps(Integers,[[2,4],[3,9]]);
[4/2] U [9/3]
]]>
</Example>
  </Description>
</ManSection>

<Index Key="Modulus" Subkey="U"><C>Modulus</C></Index>
<Index Key="Classes" Subkey="U"><C>Classes</C></Index>
<Index Key="AsListOfClasses" Subkey="U"><C>AsListOfClasses</C></Index>

There is a method for the operation <C>Modulus</C> which returns the lcm of
the moduli of the residue classes forming such a union. Further there is an
operation <C>Classes</C> for retrieving the list of classes which has been
passed as an argument to <C>ResidueClassUnionWithFixedReps</C>.
The operation <C>AsListOfClasses</C> does the same except that the returned
list contains residue classes instead of pairs
<C>[<A>modulus</A>,<A>residue</A>]</C>. There are methods for <C>Print</C>,
<C>String</C> and <C>Display</C> available for unions of residue classes
with fixed representatives.

<ManSection>
  <Func Name="AllResidueClassesWithFixedRepsModulo"
        Arg="R, m" Label="R, m"/>
  <Func Name="AllResidueClassesWithFixedRepsModulo"
        Arg="m" Label="m"/>
  <Returns>
    A sorted list of all residue classes (mod&nbsp;<A>m</A>)
    of the ring&nbsp;<A>R</A>, with fixed representatives.
  </Returns>
  <Description>
    If the argument <A>R</A> is omitted it defaults to the default ring
    of&nbsp;<A>m</A>, cp. the documentation of <C>DefaultRing</C> in the
    &GAP; reference manual. The representatives are the same as those
    chosen by the operation <C>mod</C>.
    See also <Ref Func="AllResidueClassesModulo" Label="R, m"/>.
<Example>
<![CDATA[
gap> AllResidueClassesWithFixedRepsModulo(Z_pi(2),4);
[ [0/4], [1/4], [2/4], [3/4] ]
gap> AllResidueClassesWithFixedRepsModulo(9);
[ [0/9], [1/9], [2/9], [3/9], [4/9], [5/9], [6/9], [7/9], [8/9] ]
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:MethodsForResidueClassUnions">
<Heading>
  Methods for unions of residue classes with fixed representatives
</Heading>

Throughout this chapter, the argument <A>R</A> denotes the underlying ring,
and the arguments <A>U</A>, <A>U1</A> and&nbsp;<A>U2</A> denote unions of
residue classes of <A>R</A> with fixed representatives. <P/>

Unions of residue classes with fixed representatives are multisets.
Elements and residue classes can be contained with multiplicities:

<ManSection>
  <Meth Name="Multiplicity" Arg="x, U" Label="x, U"/>
  <Meth Name="Multiplicity" Arg="cl, U" Label="cl, U"/>
  <Returns>
    The multiplicity of <A>x</A> in&nbsp;<A>U</A> regarded as a multiset
    of ring elements, resp. the multiplicity of the residue class <A>cl</A>
    in&nbsp;<A>U</A> regarded as a multiset of residue classes.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> U := ResidueClassUnionWithFixedReps(Integers,[[2,0],[3,0]]);
[0/2] U [0/3]
gap> List([0..23],n->Multiplicity(n,U));
[ 2, 0, 1, 1, 1, 0, 2, 0, 1, 1, 1, 0, 2, 0, 1, 1, 1, 0, 2, 0, 1, 1, 1, 0 ]
gap> Multiplicity(ResidueClassWithFixedRep(2,0),U);
1
]]>
</Example>
  </Description>
</ManSection>

<Index Key="Density" Subkey="U"><C>Density</C></Index>
<Index Key="IsOverlappingFree" Subkey="U"><C>IsOverlappingFree</C></Index>
<Index Key="AsOrdinaryUnionOfResidueClasses" Subkey="U">
  <C>AsOrdinaryUnionOfResidueClasses</C>
</Index>

A union of residue classes with fixed representatives can have an attribute
<C>Density</C> which denotes its <E>natural density</E> as a multiset, i.e.
elements with multiplicity&nbsp;<M>k</M> count <M>k</M>-fold.
A union of residue classes with fixed representatives has the property
<C>IsOverlappingFree</C> if it consists of pairwise disjoint residue
classes. The set-theoretic union of the residue classes forming a union
of residue classes with fixed representatives can be determined by the
operation <C>AsOrdinaryUnionOfResidueClasses</C>. The object returned
by this operation is an <Q>ordinary</Q> residue class union as described
in Chapter&nbsp;<Ref Label="ch:UnionsOfResidueClasses"/>.

<Example>
<![CDATA[
gap> U := ResidueClassUnionWithFixedReps(Integers,[[2,0],[3,0]]);
[0/2] U [0/3]
gap> Density(U);
5/6
gap> IsOverlappingFree(U);
false
gap> AsOrdinaryUnionOfResidueClasses(U);
Z \ Union of the residue classes 1(6) and 5(6) of Z
gap> Density(last);
2/3
]]>
</Example>

All statements made below on a certain invariant&nbsp;<M>\delta</M>
(<M>\rightarrow</M>&nbsp;<Ref Attr="Delta" Label="U"/>)
apply only to the case that <A>R</A> is the ring of integers.

<ManSection>
  <Meth Name="Union" Arg="U1, U2" Label="U1, U2"/>
  <Returns>
    The union of <A>U1</A> and&nbsp;<A>U2</A>.
  </Returns>
  <Description>
    The multiplicity of any ring element resp. residue class in
    the union is the sum of its multiplicities in the arguments. 
    It holds <C>Delta(Union(<A>U1</A>,<A>U2</A>))
    = Delta(<A>U1</A>) + Delta(<A>U2</A>)</C>.
    (<M>\rightarrow</M>&nbsp;<Ref Attr="Delta" Label="U"/>).
<Example>
<![CDATA[
gap> U := ResidueClassUnionWithFixedReps(Integers,[[2,0],[3,0]]);
[0/2] U [0/3]
gap> Union(U,U);                                      
[0/2] U [0/2] U [0/3] U [0/3]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="Intersection" Arg="U1, U2" Label="U1, U2"/>
  <Returns>
    The intersection of <A>U1</A> and&nbsp;<A>U2</A>.
  </Returns>
  <Description>
    The multiplicity of any ring element resp. residue class in the
    intersection is the minimum of its multiplicities in the arguments. 
<Example>
<![CDATA[
gap> U := ResidueClassUnionWithFixedReps(Integers,[[2,0],[3,0]]);
[0/2] U [0/3]
gap> Intersection(U,ResidueClassWithFixedRep(2,0));
[0/2]
gap> Intersection(U,ResidueClassWithFixedRep(6,0));
Empty union of residue classes of Z with fixed representatives
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="Difference" Arg="U1, U2" Label="U1, U2"/>
  <Returns>
    The difference of <A>U1</A> and&nbsp;<A>U2</A>.
  </Returns>
  <Description>
    The multiplicity of any residue class in the difference is its
    multiplicity in&nbsp;<A>U1</A> minus its multiplicity in&nbsp;<A>U2</A>,
    if this value is nonnegative. The difference of the empty residue class
    union with fixed representatives and some residue class <M>[r/m]</M>
    is set equal to <M>[(m-r)/m]</M>.
    It holds <C>Delta(Difference(<A>U1</A>,<A>U2</A>))
    = Delta(<A>U1</A>) - Delta(<A>U2</A>)</C>.
    (<M>\rightarrow</M>&nbsp;<Ref Attr="Delta" Label="U"/>).
<Example>
<![CDATA[
gap> U := ResidueClassUnionWithFixedReps(Integers,[[2,0],[3,0]]);
[0/2] U [0/3]
gap> V := ResidueClassUnionWithFixedReps(Integers,[[3,0],[5,2]]);
[0/3] U [2/5]
gap> Difference(U,V);
[0/2] U [3/5]
]]>
</Example>
  </Description>
</ManSection>

In the sequel we abbreviate the term <Q>the multiset of ring elements
endowed with the structure of a union of residue classes with fixed
representatives</Q> by <Q>the multiset</Q>.

<ManSection>
  <Meth Name="\+" Arg="U, x" Label="U, x"/>
  <Meth Name="\+" Arg="x, U" Label="x, U"/>
  <Returns>
    The multiset of sums <M>u + x</M>, <M>u \in U</M>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> U := ResidueClassUnionWithFixedReps(Integers,[[2,0],[3,0]]);
[0/2] U [0/3]
gap> U + 7;
[7/2] U [7/3]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="\-" Arg="U, x" Label="U, x"/>
  <Meth Name="\-" Arg="x, U" Label="x, U"/>
  <Meth Name="\-" Arg="U" Label="U"/>
  <Returns>
    The multiset of differences <M>u - x</M>, <M>u \in U</M> resp. the
    multiset of differences <M>x - u</M>, <M>u \in U</M> resp. the multiset
    of the additive inverses of the elements of&nbsp;<M>U</M>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> U := ResidueClassUnionWithFixedReps(Integers,[[2,0],[3,0]]);
[0/2] U [0/3]
gap> U - 7; 7 - U; -U;
[-7/2] U [-7/3]
[7/-3] U [7/-2]
[0/-3] U [0/-2]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="\*" Arg="U, x" Label="U, x"/>
  <Meth Name="\*" Arg="x, U" Label="x, U"/>
  <Returns>
    The multiset of products <M>x \cdot u</M>, <M>u \in U</M>.
  </Returns>
  <Description>
    Scalar multiplication leaves <M>\delta</M> invariant
    (<M>\rightarrow</M>&nbsp;<Ref Attr="Delta" Label="U"/>).
<Example>
<![CDATA[
gap> U := ResidueClassUnionWithFixedReps(Integers,[[2,0],[3,0]]);
[0/2] U [0/3]
gap> 2 * U;
[0/4] U [0/6]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="\/" Arg="U, x" Label="U, x"/>
  <Returns>
    The multiset of quotients <M>u/x</M>, <M>u \in U</M>.
  </Returns>
  <Description>
    Scalar division leaves <M>\delta</M> invariant
    (<M>\rightarrow</M>&nbsp;<Ref Attr="Delta" Label="U"/>).
    If not all elements of all residue classes in <A>U</A> are divisible
    by&nbsp;<A>x</A>, the method gives up.
<Example>
<![CDATA[
gap> U := ResidueClassUnionWithFixedReps(Integers,[[4,0],[6,0]]);
[0/4] U [0/6]
gap> U/2;
[0/2] U [0/3]
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:DeltaAndRho">
<Heading>
  The invariant Delta
</Heading>

<ManSection>
  <Attr Name="Delta" Arg="U" Label="U"/>
  <Returns>
    The value of the invariant <M>\delta</M> of the
    residue class union&nbsp;<A>U</A>.
  </Returns>
  <Description>
    For a residue class <M>[r/m]</M> with fixed representative we set
    <M>\delta([r/m]) := r/m - 1/2</M> and extend this definition additively
    to unions of such residue classes. If no representatives are fixed,
    this definition is still unique (mod&nbsp;1).
<Example>
<![CDATA[
gap> U := ResidueClassUnionWithFixedReps(Integers,[[2,4],[3,9]]);
[4/2] U [9/3]
gap> Delta(U);             
4
gap> last = (4/2-1/2) + (9/3-1/2);
true
gap> V := RepresentativeStabilizingRefinement(U,3);
[4/6] U [6/6] U [8/6] U [9/9] U [12/9] U [15/9]
gap> Delta(V);
4
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="Rho" Arg="U" Label="U"/>
  <Returns>
    The value of the invariant <M>\rho</M> of the residue class
    union&nbsp;<A>U</A>, i.e <M>e^{\pi i \delta(U)}</M>
    (<M>\rightarrow</M>&nbsp;<Ref Attr="Delta" Label="U"/>).
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> U := ResidueClassUnionWithFixedReps(Integers,[[2,3],[3,4]]);
[3/2] U [4/3]
gap> Rho(U); Rho(2*U);
E(12)^11
E(12)^11
gap> Rho(Union(U,U));                                            
-E(3)
gap> last = Rho(U)^2;
true
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="RepresentativeStabilizingRefinement" Arg="U, k" Label="U, k"/>
  <Returns>
    The representative stabilizing refinement of <A>U</A>
    into <M>k</M>&nbsp;parts.
  </Returns>
  <Description>
    The <E>representative stabilizing refinement</E> of a residue class
    <M>[r/m]</M> of <M>\Z</M> into <M>k</M> parts is defined by
    <M>[r/km] \cup [(r+m)/km] \cup \dots \cup [(r+(k-1)m)/km]</M>.
    This definition is extended in the obvious way to unions of residue
    classes. <P/>

    If the argument <A>k</A> is zero, the method performs a simplification
    of <A>U</A> by joining appropriate residue classes, if this is possible.
    <P/>

    In any case the value of <C>Delta(<A>U</A>)</C> is invariant under
    this operation (<M>\rightarrow</M>&nbsp;<Ref Attr="Delta" Label="U"/>).
<Example>
<![CDATA[
gap> U := ResidueClassUnionWithFixedReps(Integers,[[2,0],[3,0]]);
[0/2] U [0/3]
gap> RepresentativeStabilizingRefinement(U,4);   
[0/8] U [2/8] U [4/8] U [6/8] U [0/12] U [3/12] U [6/12] U [9/12]
gap> RepresentativeStabilizingRefinement(last,0);
[0/2] U [0/3]
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:CategoriesOfUnionsOfResidueClassesWithFixedReps">
<Heading>
  The categories of unions of residue classes with fixed rep's
</Heading>

The names of the categories of unions of residue classes with fixed
representatives are derived from the names of those of the
<Q>ordinary</Q> unions of residue classes given in
Section&nbsp;<Ref Label="sec:CategoriesOfUnionsOfResidueClasses" />
by appending <C>WithFixedRepresentatives</C>.

</Section>

<!-- #################################################################### -->

</Chapter>

<!-- #################################################################### -->
